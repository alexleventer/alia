<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>qbits.alia.policy.load-balancing documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Alia-all</span> <span class="project-version">4.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>qbits</span></div></div></li><li class="depth-2"><a href="qbits.alia.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alia</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.cluster-options.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cluster-options</span></div></a></li><li class="depth-3"><a href="qbits.alia.codec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codec</span></div></a></li><li class="depth-4 branch"><a href="qbits.alia.codec.default.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>default</span></div></a></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>extension</span></div></div></li><li class="depth-5"><a href="qbits.alia.codec.extension.joda-time.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>joda-time</span></div></a></li><li class="depth-4"><a href="qbits.alia.codec.udt-aware.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>udt-aware</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.enum.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>enum</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.manifold.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>manifold</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>policy</span></div></div></li><li class="depth-4 branch"><a href="qbits.alia.policy.address-translator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>address-translator</span></div></a></li><li class="depth-4 branch current"><a href="qbits.alia.policy.load-balancing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>load-balancing</span></div></a></li><li class="depth-4 branch"><a href="qbits.alia.policy.reconnection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reconnection</span></div></a></li><li class="depth-4 branch"><a href="qbits.alia.policy.retry.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>retry</span></div></a></li><li class="depth-4"><a href="qbits.alia.policy.speculative-execution.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>speculative-execution</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.query-logger.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>query-logger</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.timestamp-generator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timestamp-generator</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.tuple.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tuple</span></div></a></li><li class="depth-3 branch"><a href="qbits.alia.udt.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>udt</span></div></a></li><li class="depth-3"><a href="qbits.alia.uuid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uuid</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-dc-aware-round-robin-policy"><div class="inner"><span>dc-aware-round-robin-policy</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-latency-aware-balance-policy"><div class="inner"><span>latency-aware-balance-policy</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-make"><div class="inner"><span>make</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-map-.3Edc-aware-round-robin-policy"><div class="inner"><span>map-&gt;dc-aware-round-robin-policy</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-map-.3Ewhitelist-policy"><div class="inner"><span>map-&gt;whitelist-policy</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-round-robin-policy"><div class="inner"><span>round-robin-policy</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-socket-address"><div class="inner"><span>socket-address</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-token-aware-policy"><div class="inner"><span>token-aware-policy</span></div></a></li><li class="depth-1"><a href="qbits.alia.policy.load-balancing.html#var-whitelist-policy"><div class="inner"><span>whitelist-policy</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">qbits.alia.policy.load-balancing</h1><div class="doc"><div class="markdown"><p>The policy that decides which Cassandra hosts to contact for each new query.</p></div></div><div class="public anchor" id="var-dc-aware-round-robin-policy"><h3>dc-aware-round-robin-policy</h3><div class="usage"><code>(dc-aware-round-robin-policy dc used-hosts-per-remote-dc)</code><code>(dc-aware-round-robin-policy dc)</code></div><div class="doc"><div class="markdown"><p>A data-center aware Round-robin load balancing policy.</p>
<p>This policy provides round-robin queries over the node of the local datacenter. It also includes in the query plans returned a configurable number of hosts in the remote datacenters, but those are always tried after the local nodes. In other words, this policy guarantees that no host in a remote datacenter will be queried unless no host in the local datacenter can be reached.</p>
<p>If used with a single datacenter, this policy is equivalent to the LoadBalancingPolicy.RoundRobin policy, but its DC awareness incurs a slight overhead so the <code>round-robin-policy</code> policy could be prefered to this policy in that case.</p>
<p><a href="http://www.datastax.com/drivers/java/apidocs/com/datastax/driver/core/policies/DCAwareRoundRobinPolicy.html">http://www.datastax.com/drivers/java/apidocs/com/datastax/driver/core/policies/DCAwareRoundRobinPolicy.html</a></p></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L57">view source</a></div></div><div class="public anchor" id="var-latency-aware-balance-policy"><h3>latency-aware-balance-policy</h3><div class="usage"><code>(latency-aware-balance-policy child {:keys [exclusion-threshold min-measure retry-period scale update-rate]})</code></div><div class="doc"><div class="markdown"><p>A wrapper load balancing policy that adds latency awareness to a child policy.</p>
<p>When used, this policy will collect the latencies of the queries to each Cassandra node and maintain a per-node latency score (an average). Based on these scores, the policy will penalize (technically, it will ignore them unless no other nodes are up) the nodes that are slower than the best performing node by more than some configurable amount (the exclusion threshold).</p>
<p>The latency score for a given node is a based on a form of exponential moving average. In other words, the latency score of a node is the average of its previously measured latencies, but where older measurements gets an exponentially decreasing weight. The exact weight applied to a newly received latency is based on the time elapsed since the previous measure (to account for the fact that latencies are not necessarily reported with equal regularity, neither over time nor between different nodes).</p>
<p>Once a node is excluded from query plans (because its averaged latency grew over the exclusion threshold), its latency score will not be updated anymore (since it is not queried). To give a chance to this node to recover, the policy has a configurable retry period. The policy will not penalize a host for which no measurement has been collected for more than this retry period.</p></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L102">view source</a></div></div><div class="public anchor" id="var-make"><h3>make</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L163">view source</a></div></div><div class="public anchor" id="var-map-.3Edc-aware-round-robin-policy"><h3>map-&gt;dc-aware-round-robin-policy</h3><div class="usage"><code>(map-&gt;dc-aware-round-robin-policy {:keys [data-centre used-hosts-per-remote-dc]})</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L170">view source</a></div></div><div class="public anchor" id="var-map-.3Ewhitelist-policy"><h3>map-&gt;whitelist-policy</h3><div class="usage"><code>(map-&gt;whitelist-policy {:keys [child white-list]})</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L165">view source</a></div></div><div class="public anchor" id="var-round-robin-policy"><h3>round-robin-policy</h3><div class="usage"><code>(round-robin-policy)</code></div><div class="doc"><div class="markdown"><p>A Round-robin load balancing policy.</p>
<p>This policy queries nodes in a round-robin fashion. For a given query, if an host fail, the next one (following the round-robin order) is tried, until all hosts have been tried.</p>
<p>This policy is not datacenter aware and will include every known Cassandra host in its round robin algorithm. If you use multiple datacenter this will be inefficient and you will want to use the <code>dc-aware-round-robin-policy</code> load balancing policy instead.</p>
<p><a href="http://www.datastax.com/drivers/java/apidocs/com/datastax/driver/core/policies/RoundRobinPolicy.html">http://www.datastax.com/drivers/java/apidocs/com/datastax/driver/core/policies/RoundRobinPolicy.html</a></p></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L17">view source</a></div></div><div class="public anchor" id="var-socket-address"><h3>socket-address</h3><div class="usage"><code>(socket-address {:keys [ip hostname port]})</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L153">view source</a></div></div><div class="public anchor" id="var-token-aware-policy"><h3>token-aware-policy</h3><div class="usage"><code>(token-aware-policy child)</code></div><div class="doc"><div class="markdown"><p>A wrapper load balancing policy that add token awareness to a child policy.</p>
<p>This policy encapsulates another policy. The resulting policy works in the following way:</p>
<p>the distance method is inherited from the child policy. the iterator return by the newQueryPlan method will first return the LOCAL replicas for the query (based on Query.getRoutingKey()) if possible (i.e. if the query getRoutingKey method doesn’t return null and if Metadata.getReplicas(java.nio.ByteBuffer) returns a non empty set of replicas for that partition key). If no local replica can be either found or successfully contacted, the rest of the query plan will fallback to one of the child policy. Do note that only replica for which the child policy distance method returns HostDistance.LOCAL will be considered having priority. For example, if you wrap DCAwareRoundRobinPolicy with this token aware policy, replicas from remote data centers may only be returned after all the host of the local data center.</p>
<p><a href="http://www.datastax.com/drivers/java/apidocs/com/datastax/driver/core/policies/TokenAwarePolicy.html">http://www.datastax.com/drivers/java/apidocs/com/datastax/driver/core/policies/TokenAwarePolicy.html</a></p></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L33">view source</a></div></div><div class="public anchor" id="var-whitelist-policy"><h3>whitelist-policy</h3><div class="usage"><code>(whitelist-policy child whitelist-coll)</code></div><div class="doc"><div class="markdown"><p>A load balancing policy wrapper that ensure that only hosts from a provided white list will ever be returned.</p>
<p>This policy wraps another load balancing policy and will delegate the choice of hosts to the wrapped policy with the exception that only hosts contained in the white list provided when constructing this policy will ever be returned. Any host not in the while list will be considered {@code IGNORED} and thus will not be connected to.</p>
<p>This policy can be useful to ensure that the driver only connects to a predefined set of hosts. Keep in mind however that this policy defeats somewhat the host auto-detection of the driver. As such, this policy is only useful in a few special cases or for testing, but is not optimal in general. If all you want to do is limiting connections to hosts of the local data-center then you should use DCAwareRoundRobinPolicy and not this policy in particular.</p></div></div><div class="src-link"><a href="https://github.com/mpenet/alia/blob/master/modules/alia/src/qbits/alia/policy/load_balancing.clj#L81">view source</a></div></div></div></body></html>